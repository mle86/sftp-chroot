<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>sftp-chroot by mle86</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">sftp-chroot</h1>
      <h2 class="project-tagline">Working home-chrooted sftp</h2>
      <a href="https://github.com/mle86/sftp-chroot" class="btn">View on GitHub</a>
      <a href="https://github.com/mle86/sftp-chroot/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mle86/sftp-chroot/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p>This project aims to provide a working solution
for homedir-chrooted sftp
using the openssh-server's <strong>internal-sftp</strong> subsystem
and <strong>automount</strong>(8).</p>

<h3>
<a id="goals" class="anchor" href="#goals" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Goals</h3>

<p>We'd like to have one user group, <code>sftp</code>,
which <strong>prevents its members from regular <em>ssh</em> logins</strong>
and causes <strong>homedir chrooting</strong>.</p>

<p>We'd also like to <strong>support sub-accounts</strong> with <em>User Private Groups:</em></p>

<ul>
<li>Main account <code>uid=1000(mle) gid=1000(mle) groups=(1000)mle,(500)sftp</code><br>
with homedir <code>/home/mle</code><br>
should be able to access /home/mle via sftp, including all sub-directories.</li>
<li>Sub account <code>uid=1001(mle-sub) gid=1000(mle) groups=(1000)mle,(500)sftp</code><br>
with homedir <code>/home/mle/sub</code><br>
should be able to access /home/mle/sub via sftp, but NOT the rest of /home/mle.</li>
<li>Those accounts own their respective homedirs.</li>
</ul>

<p>If both accounts have a umask of <code>002</code> (or something even more permissive),
they can access each others files.<br>
The sub-account however should be <strong>prevented from leaving its own homedir.</strong>
This is what we need the chroot mechanism for.</p>

<h3>
<a id="ownership-problem" class="anchor" href="#ownership-problem" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ownership problem</h3>

<p>While the <code>internal-sftp</code> sshd subsystem allows "lightweight" chrooting, that is, without requiring /dev/null, /bin/sh, etc,
it still comes with a serious restriction:<br>
<strong>All components of the user's homedir have to be non-world-writable and owned by <code>root</code>.</strong></p>

<p>While /home certainly is root-owned,
the subdirectories in there are not --
and we don't want to force our users to have root-owned homedirs.</p>

<h3>
<a id="bind-mounts" class="anchor" href="#bind-mounts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bind mounts</h3>

<p><em>Bind mounts</em> are a way to have <strong>one directory in two places</strong>,
sort of like temporary directory hard links.</p>

<p>For example, this bind mount makes my home directory available at a second location:</p>

<pre><code>$ ls -ld /mnt/
drwxr-xr-x 2 root root 4,0K Jul 19  2015 /mnt/
# mount  -o bind  $HOME /mnt
$ ls -ld /mnt/
drwxr-x---+ 77 mle mle 4,0K Jun  2 00:20 /mnt/
</code></pre>

<p>As can be seen,
<strong>the secondary location now has the same ownership and access mode as my "real" homedir.</strong>
It will last until /mnt get unmounted or the machine reboots.</p>

<h4>
<a id="security-problems-with-bind-mounts" class="anchor" href="#security-problems-with-bind-mounts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Security problems with bind mounts</h4>

<p>They also pose a security risk if applied too liberally:<br>
Usually, settings one's homedir's access mode to <code>0700</code> is sufficient to protect all of its contents.
Even subdirectories and files with permissive modes like <code>0777</code> are still safe from other users
simply because nobody can enter that homedir at all.<br>
<strong>Bind mounts circumvent this!</strong></p>

<p>For example:</p>

<pre><code># ls -la /root/
drwx------  25 root root 4,0K Jun  2 01:09 ./   # No one can get in here.
drwxrwxrwx   2 root root 4,0K Jun  2 01:09 secrets/   # Perfectly safe, right?
# mount -o bind /root/secrets /mnt
$ ls -ld /mnt
drwxrwxrwx 2 root root 4,0K Jun  2 01:09 /mnt   # Oops!
</code></pre>

<p>Because <code>/mnt</code> can be reached by everyone (because <code>/</code> is, of course, unrestricted),
everybody can now effectively enter <code>/root/secrets/</code> --
it is no longer protected by <code>/root/</code>'s restrictive access mode.</p>

<p>It is therefore <code>root</code>'s responsibility to be very careful with bind mounts in general,
because they can be used to circumvent the mode restrictions of nested directories.</p>

<h3>
<a id="using-bind-mounts-for-ssh-chrooting" class="anchor" href="#using-bind-mounts-for-ssh-chrooting" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Using bind mounts for ssh chrooting</h3>

<p>Keeping this problem in mind,
we can create bind mounts from sub-account homedirs.
This evades <em>internal-sftp</em>'s restriction that the chroot dir must be <code>root</code>-owned:
We can duplicate the <code>/home</code> hierarchy for one user inside their new root directory.</p>

<p>We start by creating a base directory <code>/jails</code> for our bind mount points
which is owned by root and has very restrictive access modes,
so no one can enter it.
(This will still work because <em>internal-sftp</em> runs as <code>root</code> prior to chrooting,
therefore it can enter the /jails directory,
whereas logged-in non-root users cannot.)</p>

<pre><code># mkdir /jails
# chmod 0700 /jails
</code></pre>

<p>Now assume we want to allow chrooted sftp-logins for the <code>mle-sub</code> user.
Its homedir is <code>/home/mle/sub</code>.</p>

<pre><code># mkdir -p /jails/mle-sub/home/mle/sub   # all owned by root
# mount -o bind  /home/mle/sub  /jails/mle-sub/home/mle/sub
</code></pre>

<p>The chroot dir <code>/jails/mle-sub</code> is owned by root, so <em>internal-sftp</em> will accept it.
Inside it, there is the user's homedir tree, and nothing else.
The homedir is linked with the <em>real</em> homedir,
so it has the same permissions, ownership, and of course content.</p>

<h3>
<a id="getting-sshd-on-board" class="anchor" href="#getting-sshd-on-board" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting sshd on board</h3>

<p>Appending this block to <code>/etc/ssh/sshd_config</code>
tells <em>sshd</em> that all members of the <code>sftp</code> group
are to be chrooted and can only ever use sftp:</p>

<pre><code>Match group sftp
    ChrootDirectory /jails/%u   # sftp will replace %u with the username.
    ForceCommand internal-sftp
</code></pre>

<h3>
<a id="so-far-so-good" class="anchor" href="#so-far-so-good" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>So far so good</h3>

<p>Now if the user <code>mle-sub</code> establishes a sftp connection,
<em>internal-sftp</em> will first chroot the session to <code>/jails/mle-sub</code>,
which works because those directories both belong to root.<br>
As usual, it will then try to change into the user's homedir --
which is <code>/home/mle/sub</code>.
Inside the chroot jail, that directory exists too, so the directory change succeeds.
<code>home</code> and <code>home/mle</code> are only empty, non-writable directories inside the jail,
so the user cannot do any harm there,
while <code>home/mle/sub</code> is a bind link to the <em>real</em> homedir.</p>

<p>The user ends up with an sftp session inside their own home directory --
or at least inside a directory which seems to have the exact same path, correct permissions, and correct ownership.
Escaping that homedir with <code>cd ..</code> will only land them in an empty, non-writable directory,
not in the real <code>/home/mle</code>.</p>

<p>Success!</p>

<h3>
<a id="too-many-mounts" class="anchor" href="#too-many-mounts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Too many mounts</h3>

<p>To enable sftp logins for all <code>sftp</code> group members, we'd have to do this for every one of them:</p>

<ol>
<li>Replicate their homedir structure inside <em>/jails</em><br>
(<code># mkdir -p /jails/$username/$homedir</code>)</li>
<li>Bind mount their homedir to the fake homedir inside the jail<br>
(<code># mount -o bind $homedir /jails/$username/$homedir</code>)</li>
</ol>

<p>And of course, we'd have to do this after every reboot, because bind mounts are not durable.</p>

<p>Now we could enter all of them into our <code>/etc/fstab</code>,
but after a few dozen sub-accounts
both that file and <code>mtab</code> would get quite cluttered.</p>

<p>What if the system could automatically create and mount those directories when needed,
unmounting and removing them after the sftp session ended?</p>

<h3>
<a id="enter-autofs" class="anchor" href="#enter-autofs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Enter autofs</h3>

<p>The <em>autofs</em> package contains the <em>automount(8)</em> daemon.
Its configuration files can be placed in <code>/etc/auto.master.d/</code> (which might have to be created first).</p>

<p>We'll add our own configuration there:</p>

<pre><code>$ cat /etc/auto.master.d/jails.autofs
/jails program:/etc/autofs-jails.sh --timeout=20
</code></pre>

<p>This oneliner basically says that
whenever someone tries to enter a non-existing directory in <code>/jails/</code>,
<em>automount</em> should call the <em>autofs-jails.sh</em> script
which should then determine where to mount that directory from.</p>

<p>The <em>autofs-jails.sh</em> receives the non-existing relative directory as its first argument.
Since only <em>internal-sftp</em> will ever enter <code>/jails</code>
and we configured it to chroot to <code>/jails/%u</code>,
we know that the <em>autofs-jails.sh</em> script will receive <strong>the username of the sftp user</strong> as its first argument.</p>

<p>With that, the script performs several security checks first:</p>

<ol>
<li>Making sure that <code>/jails</code> belongs to root and has a restrictive access mode (<code>0700</code>),
so that no one can go there to circumvent homedir access restrictions.</li>
<li>Making sure that the <code>$1</code> username actually exists and has an existing homedir.</li>
<li>Making sure that the user's homedir is actually a directory, <strong>not a symlink</strong>,
or autofs will happily create a bind link to the link target (!).</li>
</ol>

<p>If everything looks good,
the script echoes a configuration line for the <em>automount</em> daemon like this:</p>

<pre><code>echo "-fstype=bind  /\"$homedir\" :\"$homedir\""
</code></pre>

<p>Let's break that down:</p>

<ol>
<li>
<code>-fstype=bind</code> -- pretty self-explanatory.
<em>automount</em>'s default filesystem is... NFS! We wouldn't want <em>that.</em>
</li>
<li>
<code>/"$homedir"</code> -- this tells <em>automount</em> which mount point to create.
It is relative to the non-existing directory which triggered the script,
so it'll be expanded to <code>/jails/$username/$homedir</code>.</li>
<li>
<code>:"$homedir"</code> -- this tells <em>automount</em> where to find the bind mount target.</li>
</ol>

<p>Effectively, this means that as soon as the <code>mle-sub</code> user logs in via sftp,
<em>internal-sftp</em> will chroot them to <code>/jails/mle-sub</code>.
This directory does not yet exist, triggering the <em>automount</em> daemon,
which will then create a bind mount
at <code>/jails/mle-sub/home/mle/sub</code> leading to the real <code>/home/mle/sub</code>.<br>
(The intermediary path components are automagically created, belonging to root with an access mode of <code>0755</code>, so thankfully our script won't have to do that -- which would be a real hassle, because the <em>autofs</em> kernel module does not like manual alterations in its directory.)<br>
The sftp user will end up in <code>/jails/mle-sub/home/mle/sub</code>
which to them looks and feels like the real <code>/home/mle/sub</code>
yet is completely isolated from the rest of the <code>/home/mle</code> tree.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mle86/sftp-chroot">sftp-chroot</a> is maintained by <a href="https://github.com/mle86">mle86</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

{
  "name": "sftp-chroot",
  "tagline": "Working home-chrooted sftp",
  "body": "This project aims to provide a working solution\r\nfor homedir-chrooted sftp\r\nusing the openssh-server's **internal-sftp** subsystem\r\nand **automount**(8).\r\n\r\n### Goals\r\n\r\nWe'd like to have one user group, `sftp`,\r\nwhich **prevents its members from regular *ssh* logins**\r\nand causes **homedir chrooting**.\r\n\r\nWe'd also like to **support sub-accounts** with *User Private Groups:*\r\n\r\n* Main account `uid=1000(mle) gid=1000(mle) groups=(1000)mle,(500)sftp`  \r\n  with homedir `/home/mle`  \r\n  should be able to access /home/mle via sftp, including all sub-directories.\r\n* Sub account `uid=1001(mle-sub) gid=1000(mle) groups=(1000)mle,(500)sftp`  \r\n  with homedir `/home/mle/sub`  \r\n  should be able to access /home/mle/sub via sftp, but NOT the rest of /home/mle.\r\n* Those accounts own their respective homedirs.\r\n\r\nIf both accounts have a umask of `002` (or something even more permissive),\r\nthey can access each others files.  \r\nThe sub-account however should be **prevented from leaving its own homedir.**\r\nThis is what we need the chroot mechanism for.\r\n\r\n\r\n### Ownership problem\r\n\r\nWhile the `internal-sftp` sshd subsystem allows \"lightweight\" chrooting, that is, without requiring /dev/null, /bin/sh, etc,\r\nit still comes with a serious restriction:  \r\n**All components of the user's homedir have to be non-world-writable and owned by `root`.**\r\n\r\nWhile /home certainly is root-owned,\r\nthe subdirectories in there are not --\r\nand we don't want to force our users to have root-owned homedirs.\r\n\r\n\r\n### Bind mounts\r\n\r\n*Bind mounts* are a way to have **one directory in two places**,\r\nsort of like temporary directory hard links.\r\n\r\nFor example, this bind mount makes my home directory available at a second location:\r\n```\r\n$ ls -ld /mnt/\r\ndrwxr-xr-x 2 root root 4,0K Jul 19  2015 /mnt/\r\n# mount  -o bind  $HOME /mnt\r\n$ ls -ld /mnt/\r\ndrwxr-x---+ 77 mle mle 4,0K Jun  2 00:20 /mnt/\r\n```\r\nAs can be seen,\r\n**the secondary location now has the same ownership and access mode as my \"real\" homedir.**\r\nIt will last until /mnt get unmounted or the machine reboots.\r\n\r\n#### Security problems with bind mounts\r\n\r\nThey also pose a security risk if applied too liberally:  \r\nUsually, settings one's homedir's access mode to `0700` is sufficient to protect all of its contents.\r\nEven subdirectories and files with permissive modes like `0777` are still safe from other users\r\nsimply because nobody can enter that homedir at all.  \r\n**Bind mounts circumvent this!**\r\n\r\nFor example:\r\n```\r\n# ls -la /root/\r\ndrwx------  25 root root 4,0K Jun  2 01:09 ./   # No one can get in here.\r\ndrwxrwxrwx   2 root root 4,0K Jun  2 01:09 secrets/   # Perfectly safe, right?\r\n# mount -o bind /root/secrets /mnt\r\n$ ls -ld /mnt\r\ndrwxrwxrwx 2 root root 4,0K Jun  2 01:09 /mnt   # Oops!\r\n```\r\n\r\nBecause `/mnt` can be reached by everyone (because `/` is, of course, unrestricted),\r\neverybody can now effectively enter `/root/secrets/` --\r\nit is no longer protected by `/root/`'s restrictive access mode.\r\n\r\nIt is therefore `root`'s responsibility to be very careful with bind mounts in general,\r\nbecause they can be used to circumvent the mode restrictions of nested directories.\r\n\r\n\r\n### Using bind mounts for ssh chrooting\r\n\r\nKeeping this problem in mind,\r\nwe can create bind mounts from sub-account homedirs.\r\nThis evades *internal-sftp*'s restriction that the chroot dir must be `root`-owned:\r\nWe can duplicate the `/home` hierarchy for one user inside their new root directory.\r\n\r\nWe start by creating a base directory `/jails` for our bind mount points\r\nwhich is owned by root and has very restrictive access modes,\r\nso no one can enter it.\r\n(This will still work because *internal-sftp* runs as `root` prior to chrooting,\r\ntherefore it can enter the /jails directory,\r\nwhereas logged-in non-root users cannot.)\r\n\r\n```\r\n# mkdir /jails\r\n# chmod 0700 /jails\r\n```\r\n\r\nNow assume we want to allow chrooted sftp-logins for the `mle-sub` user.\r\nIts homedir is `/home/mle/sub`.\r\n\r\n```\r\n# mkdir -p /jails/mle-sub/home/mle/sub   # all owned by root\r\n# mount -o bind  /home/mle/sub  /jails/mle-sub/home/mle/sub\r\n```\r\n\r\nThe chroot dir `/jails/mle-sub` is owned by root, so *internal-sftp* will accept it.\r\nInside it, there is the user's homedir tree, and nothing else.\r\nThe homedir is linked with the *real* homedir,\r\nso it has the same permissions, ownership, and of course content.\r\n\r\n\r\n### Getting sshd on board\r\n\r\nAppending this block to `/etc/ssh/sshd_config`\r\ntells *sshd* that all members of the `sftp` group\r\nare to be chrooted and can only ever use sftp:\r\n\r\n```\r\nMatch group sftp\r\n    ChrootDirectory /jails/%u   # sftp will replace %u with the username.\r\n    ForceCommand internal-sftp\r\n```\r\n\r\n### So far so good\r\n\r\nNow if the user `mle-sub` establishes a sftp connection,\r\n*internal-sftp* will first chroot the session to `/jails/mle-sub`,\r\nwhich works because those directories both belong to root.  \r\nAs usual, it will then try to change into the user's homedir --\r\nwhich is `/home/mle/sub`.\r\nInside the chroot jail, that directory exists too, so the directory change succeeds.\r\n`home` and `home/mle` are only empty, non-writable directories inside the jail,\r\nso the user cannot do any harm there,\r\nwhile `home/mle/sub` is a bind link to the *real* homedir.\r\n\r\nThe user ends up with an sftp session inside their own home directory --\r\nor at least inside a directory which seems to have the exact same path, correct permissions, and correct ownership.\r\nEscaping that homedir with `cd ..` will only land them in an empty, non-writable directory,\r\nnot in the real `/home/mle`.\r\n\r\nSuccess!\r\n\r\n\r\n### Too many mounts\r\n\r\nTo enable sftp logins for all `sftp` group members, we'd have to do this for every one of them:\r\n\r\n1. Replicate their homedir structure inside */jails*  \r\n   (`# mkdir -p /jails/$username/$homedir`)\r\n1. Bind mount their homedir to the fake homedir inside the jail  \r\n   (`# mount -o bind $homedir /jails/$username/$homedir`)\r\n\r\nAnd of course, we'd have to do this after every reboot, because bind mounts are not durable.\r\n\r\nNow we could enter all of them into our `/etc/fstab`,\r\nbut after a few dozen sub-accounts\r\nboth that file and `mtab` would get quite cluttered.\r\n\r\nWhat if the system could automatically create and mount those directories when needed,\r\nunmounting and removing them after the sftp session ended?\r\n\r\n\r\n### Enter autofs\r\n\r\nThe *autofs* package contains the *automount(8)* daemon.\r\nIts configuration files can be placed in `/etc/auto.master.d/` (which might have to be created first).\r\n\r\nWe'll add our own configuration there:\r\n```\r\n$ cat /etc/auto.master.d/jails.autofs\r\n/jails program:/etc/autofs-jails.sh --timeout=20\r\n```\r\n\r\nThis oneliner basically says that\r\nwhenever someone tries to enter a non-existing directory in `/jails/`,\r\n*automount* should call the *autofs-jails.sh* script\r\nwhich should then determine where to mount that directory from.\r\n\r\nThe *autofs-jails.sh* receives the non-existing relative directory as its first argument.\r\nSince only *internal-sftp* will ever enter `/jails`\r\nand we configured it to chroot to `/jails/%u`,\r\nwe know that the *autofs-jails.sh* script will receive **the username of the sftp user** as its first argument.\r\n\r\nWith that, the script performs several security checks first:\r\n\r\n1. Making sure that `/jails` belongs to root and has a restrictive access mode (`0700`),\r\n   so that no one can go there to circumvent homedir access restrictions.\r\n1. Making sure that the `$1` username actually exists and has an existing homedir.\r\n1. Making sure that the user's homedir is actually a directory, **not a symlink**,\r\n   or autofs will happily create a bind link to the link target (!).\r\n\r\nIf everything looks good,\r\nthe script echoes a configuration line for the *automount* daemon like this:\r\n```\r\necho \"-fstype=bind  /\\\"$homedir\\\" :\\\"$homedir\\\"\"\r\n```\r\n\r\nLet's break that down:\r\n\r\n1. `-fstype=bind` -- pretty self-explanatory.\r\n   *automount*'s default filesystem is... NFS! We wouldn't want *that.*\r\n1. `/\"$homedir\"` -- this tells *automount* which mount point to create.\r\n   It is relative to the non-existing directory which triggered the script,\r\n   so it'll be expanded to `/jails/$username/$homedir`.\r\n1. `:\"$homedir\"` -- this tells *automount* where to find the bind mount target.\r\n\r\nEffectively, this means that as soon as the `mle-sub` user logs in via sftp,\r\n*internal-sftp* will chroot them to `/jails/mle-sub`.\r\nThis directory does not yet exist, triggering the *automount* daemon,\r\nwhich will then create a bind mount\r\nat `/jails/mle-sub/home/mle/sub` leading to the real `/home/mle/sub`.  \r\n(The intermediary path components are automagically created, belonging to root with an access mode of `0755`, so thankfully our script won't have to do that -- which would be a real hassle, because the *autofs* kernel module does not like manual alterations in its directory.)  \r\nThe sftp user will end up in `/jails/mle-sub/home/mle/sub`\r\nwhich to them looks and feels like the real `/home/mle/sub`\r\nyet is completely isolated from the rest of the `/home/mle` tree.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}